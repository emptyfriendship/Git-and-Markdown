# 8장 병합과 충돌

---

# 8.1 병합

<br>

## 8.1.1 하나씩 직접 비교하는 수동 병합
<br>
수동으로 병합하려면 양쪽 파일을 일일이 비교하며 바뀐 점을 찾아서 적용해야 합니다.     


하지만 오류 없이 코드를 병합하는 것은 간단하지 않습니다.       

![199939079-753d6e75-25ee-4f80-9a61-ebfc5fdaa292](https://user-images.githubusercontent.com/114066603/202695246-8d70bfc7-36be-4a8b-affd-aec07edce09f.png)

<br>

## 8.1.2 깃으로 자동 병합
<br>

숙련된 개발자라고 해도 복잡한 수정 내역을 순차적인 시간에 따라 병합하는것은 쉬운 일이 아닙니다.    

깃을 사용하면 복잡한 파일을 좀 더 간편하게 병합할 수 있습니다.

+ 깃의 자동 병합은 원본을 기준으로 두 파일의 변경 이력을 비교해 자동으로 수정된 코드 내용을 병합합니다.    
        
+ 깃의 병합은 브랜치를 기준으로 합니다.
      
+ 수동 병합 작업을 깃이 대신 처리하지만 모든 코드의 병합을 완벽하게 처리할 수는 없습니다. 이를 충돌이라 합니다.

<br>

## 8.1.3 병합 방식
<br>
깃은 병합을 위해 두 가지 기본적인 알고리즘 방식을 제공합니다.       
      
깃에서 충돌 없이 병합하려면 이 두 가지 병합 방식의 차이를 알아야 합니다.    
    
+ Fast - Forword 병합    
    
+ 3 - way 병합
     
<br>

# 8.2 Fast - Forword 병합

<br>

깃의 가장 간단한 브랜치 병합은 Fast - Forword 방식입니다.
     
일반적으로 Fast - Forword 병합 방식은 혼자 개발할 때 사용합니다.
     
혼자 개발할 때는 브랜치가 생성된 커밋에 따라 순차적으로 분기됩니다.
    
이러한 순차적 커밋에 맞추어 병합을 처리하는 방법이 Fast - Forword 병합입니다.

<br>

## 8.2.1 브랜치 생성과 수정 작업

브랜치 경로가 일직선으로 1개만 있는 모양에서 작업을 할 때는     
    
Fast - Forword 방식의 알고리즘이 적용됩니다.

<br>

## 8.2.2 병합 위치


깃의 merge 명령어는 브랜치를 병합합니다.
      
 merge 명령어는 현재 브랜치르 기준으로 다른 브랜치의 모든 커밋을 병합합니다.
 
    $git merge 브랜치 이름

브랜치를 병합하려면 기준과 대상이 있어야 합니다. 

기준은 체크아웃된 현재 브랜치입니다. 

따라서 병합하려면 기준이 되는 브랜치로 이동해야 합니다.

<br>

## 8.2.3 Fast - Forword 병합 적용

아직 master 브랜치에는 추가된 커밋이 없습니다.

이러한 상태에서 두 브랜치르 병합합시다.

    info@MINGW64 /e/gitstudy08 (master)
    $ git merge feature
    Updating f123d5c..7caf5f0
    Fast-forward  
    index.htm | 6 ++++++
    1 file changed, 6 insertions(+)
    
 메세지에 Fast - Forword 방식을 사용하여 병합했다고 출력됩니다.
 
이 과정을 그림으로 나타내면 다음과 같습니다.
 
 ![200302123-2f4320e2-a04f-4a64-a184-fa6057a3303c](https://user-images.githubusercontent.com/114066603/202699776-6bc9403d-ca12-42ac-a304-7aae7fcc6520.png)

<br>

# 8.3 3 - way 병합

3 - way 병합은 좀 더 복잡한 병합을 처리할 수 있는 방법입니다.

여러 개발자와 협업으로 작업하는 경우 대부분 3 - way 병합을 사용합니다.


## 8.3.3 공통 조상

모양이 갈라지는 형태로 나뉠 때는 Fast - Forword 방식의 알고리즘을 적용하여    
병합할 수 없습니다.

이때는 다른 병합 알고리즘인 3 -way 방식을 이용해야 합니다.

두 브랜치를 병합하려면 먼저 분할 기준인 공통 커밋을 찾아야 합니다.

이를 공통 조상 커밋이라고 합니다.

공통 조상 커밋을 포함하는 브랜치와 새로운 두 브랜치, 이렇게 3개를 하나로
병합해야 합니다.

브랜치가 3개 있다고 해서 3 - way 병합이라고 합니다.

<br>

## 8.3.4 병합 커밋

병합을 성공적으로 완료한 후에는 새로운 커밋을 추가로 하나 생성합니다.

새로 생성된 커밋을 병합 커밋이라고 합니다.

병합 커밋은 부모 커밋이 2개라는 특징이 있습니다.

<br>

## 8.3.4 병합 메세지

3 - way 병합은 Fast - Forword 병합과 달리 병합 메세지가 필요합니다.

깃은 두 브랜치를 병합한 후에 새로운 커밋을 하면서 동시에 메세지를 자동 생성합니다.

자동으로 작성되는 메세지 외에 직접 커밋 메세지를 작성할 수도 있습니다.

merge 명령어를 실행 할 때 -e 또는 --edit 옵션을 사용하면 됩니다.

    $ git merge 브랜치이름 --edit
    
<br>    

# 8.4 브랜치 삭제

브랜치를 병합한 후에는 병합한 브랜치를 어떻게 관리할지 결정해야 합니다.

일반적으로 병합한 이후에는 병합된 브랜치를 삭제합니다.

<br>    

# 8.4.1 병합 후 삭제

병합된 브랜치의 커밋은 모두 원본 브랜치에 적용됩니다.

따라서 중복되는 커밋을 가지는 별도의 브랜치를 유지할 필요는 없습니다.

     $ git branch -d 브랜치이름
     
브랜치를 삭제할 때는 -d 옵션을 사용합니다.

참고로 -d 옵션은 병합을 완료한 브랜치만 삭제할 수 있습니다.

<br>

# Rebase
 
+ Git에서 한 브랜치에서 다른 브랜치로 합치는 방법은 Merge와 Rebase다.
+ Merge와 Rebase의 실행결과는 같지만 커밋 히스토리가 달라진다.
+ Merge는 쉽고 안전하지만 커밋히스토리가 지저분할 수 있다 반면 Rebase는 잘 모르고 사용할 경우 위험할 수 있어 까다롭지만 커밋히스   토리를 깔끔하게 관리할 수 있다.
+ Rebase는 base를 새롭게 설정한다는 의미로 이해하면 좋다.

    $ git rebase [newbase]














